#8 личная задача
##Имеется N прямоугольных конвертов и N прямоугольных открыток различных размеров. 
#Можно ли разложить все открытки по конвертам, 
#чтобы в каждом конверте было по одной открытке.
#Замечание. Открытки нельзя складывать, сгибать и т.п., но можно помещать в конверт под углом. 
#Например, открытка с размерами сторон 5:1 помещается в конверты с размерами 5:1, 6:3, 4.3:4.3, но не входит в конверты с размерами 4:1, 10:0.5, 4.2:4.2.
check <- function(e,e1,p,p1,st){ #е-меньшая длина конверта, 
  # е1-большая,р- меньшая длина открытки,р1-большая,st-угол  
  f <-  FALSE
  if(e < p && e1 < p1){
    f <- FALSE
  }else{
    if(e >= p && e1 >= p1){
      f <- TRUE
    }else{  #кладем открытку под неким углом phi изначально он равен 0
      phi <-  0
      while(phi < pi/2){  #почему? Хороший вопрос, pi/2 = 90, то иесть мы идем в это условие 
        #только, если одна сторона открытки больше другой *(тк это прямоугольник), если повернуть на 90 градусов открытку,
        #то она точно не поместится, так как большая сторона будет торчать
        if(sin(phi)*p1 + cos(phi)*p <= e1 &&
           cos(phi)*p1 + p*sin(phi) <= e){
          f <- TRUE
          break
        }
        phi <-  phi+st
        #print(phi) Показывает как менялся угол и как он в конце концов нашелся 
      }
    }
  }
  return(f)
}
#Если открытка входит, то нам пишут TRUE
zadacha <- function(otk,konv){
  n <- length(otk)
  print (n)
  vec <- rep(0,2*n)
  m <- matrix(vec,2*n,2*n)
  #нулевая матрица квадратная (2*n x 2*n)
  for(i in 1:n){    #для всех открыток 
    vector <- c()   #     вектор в будущем он будет логичесим, то есть мы будем в него писакть T или F
    for(j in (n+1):(2*n)) { #смотрим для конвертов
      if(sum(m[j,]==1)==0){ #если во всей j-той строчке нули,то
        temp_o <- otk[[i]]#запихиваем в переменную длины i-той открытки
        temp_k <- konv[[j-n]] #запихиваем в переменную длины j-n-ного конверта
        #для каждой открытки прогоняем конверт
        e <- min(temp_k) #меньшая сторона конверта
        e1 <- max(temp_k) #большая сторона конверта
        p <- min(temp_o) #меньшая сторона открытки
        p1 <- max(temp_o) #большая сторона открытки
        temp <- check(e,e1,p,p1,pi/100) #проверяем входит ли открытка в конверт
        vector <- c(vector,temp)
      }else{
        vector <- c(vector,FALSE)
      }
    }
    if(sum(vector!=FALSE)==0){ #Вектор состоит из FALSE нет подходящего конверта 
      stop('нет подходящего конверта')
    }
    #дальше распределяем открытки в конверты исходя из площади
    minimal <- +Inf
    for(b in which(vector==TRUE)){ #проверяем те конверты,в которых входят октрытки
      s <- (k[[b]][1])*(k[[b]][2]) #находим площадь конверта
      if(s <= minimal){
        minimal <- s
        n_min <- b
      }
    }
    m[i,n+n_min] <- 1 #1 означает что мы прошли открытку и конверт
    m[n+n_min,i] <- 1  #тк квадратная матрица
  }
  a <- graph.adjacency(m,mode ='undirected')
  plot.igraph(a,vertex.size=10)
  for(i in 1:n){
    g <-  which(m[,i]==1)
    print(paste('открытка',i,'в конверте', g-n))
  }
}
#открытки
a1 <- c(1,5)
a2 <- c(0.5,0.5)
a3 <- c(511,1)
a4 <- c(100,1)
#конверты
b1 <- c(100,2)
b2 <- c(0.5,0.5)
b3 <- c(511,4.3)
b4 <- c(4.3,4.3)
o <- list(a1,a2,a3,a4)
k <- list(b1,b2,b3,b4)
zadacha(o,k)
